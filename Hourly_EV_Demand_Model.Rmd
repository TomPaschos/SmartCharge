---
title: "Hourly EV Charging Demand Model"
author: "Danny Ettelson"
date: "11/27/2018"
output:
  pdf_document: default
  html_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r loadlib}

#load libraries
library(tidyverse)
library(dplyr)
library(RColorBrewer)


#load data
#Price Schedule
rates <- read_csv("Model_Map/2019_Winter_TOU_EV_8.csv")
Baseline_03_18_WP <- read_csv("Model_Map/03-18_WP_Avg.csv")
Chargers <- read_csv("Model_Map/Chargers_Installed_03-18.csv")

#Elasticities with format 9X3 with columns Base_Hr, Changed_Hr, and Elasticity
#Changed_Hr is the Hour where the price change occurs, Base_Hr is the hour in which demand changes
Elasticities <- read_csv("SDGE_Elasticities.csv")
SDGE_P_SOP_Ratios <- read_csv("SDGE_P_SOP_Ratios.csv")
```


```{r Context}

#Price Schedule
price_schedule <- data.frame(Hr = c(1:24)) %>% 
  mutate(P0 = rates$P0) %>% 
  mutate(period = rates$Period)

P_SOP_Ratio <- max(price_schedule$P0)/min(price_schedule$P0)

closest_schedule <- SDGE_P_SOP_Ratios$Rate_Schedule[which.min(abs(SDGE_P_SOP_Ratios$P_SOP_Ratio - P_SOP_Ratio))]

Best_Elasticities <- select(Elasticities, Base_Hr = Base_Hr, Changed_Hr = Changed_Hr, Elasticity = closest_schedule)

#price_schedule$period <- factor(price_schedule$period, levels = c("P","MP","OP"))

#Baseline
WP_Chargers <- Chargers$Workplace #Number of Chargers (C)
EV_Demand <- mutate(price_schedule, Xi = Baseline_03_18_WP$Xi, X0 = Baseline_03_18_WP$Xi/340*WP_Chargers ) #340 here comes from the number of chargers installed for the baseline


```

```{r Max_Theoretical}

#Theoretical max is based on the current number of chargers in the SCE Charge Ready pilot program, multiplied by the average power rating of Level 2 EV chargers (6.6 kW), multiplied by 1 hour.  This gives us the total number of kWh for each hour that could be achieved if every charger were utilized during the target load shift window of 11 AM - 3 PM.

Number_Chargers <- 1020
Charger_Power_Rating <- 6.6
Max_Theory <- Number_Chargers*Charger_Power_Rating

Max_Theory_df <- data.frame(Hour=c(12:15), kWh=Max_Theory)

```


```{r Splining}

x <- c(1:24) #used for the 24 hours in for loops (24 elasticity columns)


#This makes a table for each hour that lists the midpoint hours that will be splined, hours as <24, rate period, and elasticity relative to the hour.

change_points <- which(price_schedule$period != dplyr::lag(price_schedule$period)) - 1
mid_points <- change_points[-length(change_points)] +diff(change_points)/2 %>% 
  if(price_schedule$period[1] == price_schedule$period[length(price_schedule$period)])

rollover_midpoint <- (change_points[1]+24 + change_points[length(change_points)])/2 -24

for(i in x) {
    nam <- paste("Midpoints", i, sep = ".")
    
    if(between(i,9,12)) {
      
  Hrs <- sort(c(i,3.5,15,20.5))
  
} else if (between(i,13,18)) {
  
  Hrs <- sort(c(i,3.5,10,20.5))
  
} else if (between(i,19,23)) {
  
  Hrs <- sort(c(i,3.5,10,15))
  
} else
  Hrs <- sort(c(i,10,15,20.5))

#The loop above selects a set of midpoints that leaves out one midpoint based on the hour that a table is being made for (it excludes the midpoint that is in the same period as the hour of the table)

    Hrs24 <- append(Hrs,i) #adds the end point (the starting hour 24 hours later)
    Hrs <- ifelse(Hrs<i,Hrs+24,Hrs) %>% 
      append(i+24)
    #lists "real hours" from the starting point, adding 24 to any hours before the start point
    
    periods <- price_schedule$period[c(Hrs24)] 
    #retrieves the rate periods of each hour listed
    
    own_period <- price_schedule$period[i]
    #retrieves rate period of the current hour
    
    own_period_elasticities <- filter(Best_Elasticities, Base_Hr == own_period)
    midpoint_elasticities <- own_period_elasticities$Elasticity[match(periods, Elasticities$Changed_Hr)]

    
    assign(nam,data.frame(Hour=Hrs,Hrs24=Hrs24, Period=periods,Elasticity = midpoint_elasticities))
    #makes a data frame named after the current hour with each of the above variables
    
}

for (i in x) {
  current_hr <- eval(parse(text = sub("XX", i, "Midpoints.XX")))
  #calls current hours midpoint table
  
  Y = spline(x=current_hr$Hour,y=current_hr$Elasticity,xout=seq(min(current_hr$Hour),max(current_hr$Hour)))
  #splines elasticities to smoooth
  
  HR = Y$x
  
  ELAST = Y$y
  
  nam <- paste("Elasticities", i, sep = ".")
  
  assign(nam,data.frame(HR=HR,ELAST=ELAST,HR24 = ifelse(HR<=24,HR,HR-24)))
  #makes a data frame with above variables: Hours, smoothed elasticities
}


```



```{r Matrix}

#creates our matrix based on the 24 smoothed elasticities for each hour.
#uses a for loop to call files rather than individually
#NOTE this matrix has each COLUMN to be used for each hour. Our excel used each ROW if trying to compare.

matrix <- data.frame(Hr = c(1:24))
for (i in x) {
  El <- eval(parse(text = sub("YY", i, "Elasticities.YY")))
  El <- El[-1,]
  El <- El[order(El$HR24),]
  matrix <- cbind(matrix, El$ELAST)
}
matrix<-matrix[,-1]
colnames(matrix) <- c(1:24)
```



```{r Intervention}

price_change <- -0.05
intervention_hours <- c(12:15)
EV_Demand <- mutate(EV_Demand, P1 = price_schedule$P0) #Adds price schedule with intervention (P1)

EV_Demand$P1[intervention_hours] <-EV_Demand$P1[intervention_hours] + price_change #updates intervention column to implement intervention

EV_Demand <- mutate(EV_Demand, P1p = (P1-P0)/P0) #Adds percentage change in price (P1p)

X1p <- as.vector(0)
for (val in x) {
  mat <- sub("XX",val, "matrix$`XX`")
  sum_prod <- crossprod(EV_Demand$P1p,eval(parse(text = mat)))
  X1p<- append(X1p,sum_prod)
  
} #crossprod() multiplies sumproduct of the percent change in price with each column in the matrix. This is done 24 times by the for loop rather than 24 individual times

X1p <- X1p[-1] # gets rid of the first dummy entry to the variable
EV_Demand <- mutate(EV_Demand, X1p = X1p) #add percent change in demand due to price onto EV_Demand (X1p)

EV_Demand <- mutate(EV_Demand, X1 = (1+X1p)*X0) #adds new demand in kW variable (X1)


```

```{r Throttling}

throttle_amount <- -0.5 #throttling amount -0.5 - 50%
Tp <- rep(0,24)
throttle_hours <- c(7:11) #hours that throttling occurs
Tp[throttle_hours] <- throttle_amount #Assigns each hour a throttling percentage
EV_Demand <- mutate(EV_Demand, Tp=Tp) #Adds throttling percentage to each hour (Tp)

E <- as.vector(0) #dummy for self-elasticities (E)

for (val in x) {
  self <- matrix[val,val]
  E <- append(E,self)
} #checks the matrix for the self elasticity and adds it to a vector, repeated 24 times as a for loop rather than 24 times

E <- E[-1] #removing dummy

EV_Demand <- mutate(EV_Demand, Ptp = Tp/E, Pt = (1+Ptp)*P1)#Creates an equivalent change in price during that hour that would be required to see the drop in demand due to throttling

Xtp <- as.vector(0) #Dummy for change in demand due to throttling (Xtp)

for (val in x) {
  mat <- sub("XX",val, "matrix$`XX`")
  sum_prod <- crossprod(EV_Demand$Ptp,eval(parse(text = mat)))
  Xtp<- append(Xtp,sum_prod)
} #uses new price equivalent sumproduct with each hour's elasticities to find percent change in demand due to throttling
Xtp <- Xtp[-1] #gets rid of dummy

EV_Demand <- mutate(EV_Demand, Xtp = Xtp, Xt = (Xtp+1)*X1) #adds (Xtp) and the new demand in kW due to throttling (Xt)


#The variables below quantify the shift and net change in demand as a result of interventions, and need to be adjusted based on intervention (does not count throttling)
Total_x0 <- sum(EV_Demand$X0)
Total_xt <-sum(EV_Demand$Xt)

Net_Change <- Total_xt-Total_x0
Change_intervention <- sum(EV_Demand$Xt[intervention_hours]) - sum(EV_Demand$X0[intervention_hours])
Change_outside_intervention <- sum(EV_Demand$Xt[-intervention_hours])- sum(EV_Demand$X0[-intervention_hours])

```

```{r Communication}

#to be completed...

```


```{r Outputs}

#Load Emissions Factors
Hourly_EF <- read_csv("Hrly_EF.csv")
# Current hourly EF csv is fake. Numbers will be in lbs/kwh for both CO2 and NOX.

#Create Date Frame for Emissions Outputs

Emissions <- data.frame(Hr = c(1:24)) %>% 
  mutate(CO2EF = Hourly_EF$CO2) %>% 
  mutate(NOXEF = Hourly_EF$NOX) %>% 
  mutate(X0 = EV_Demand$X0) %>% # column for initial demand at each hour
  mutate(Xf = EV_Demand$Xt)  # column for new demand at each hour. we'll need to update "Xt" to reflect the new column post comms/all interventions

#calculate change in Xf and relevant change in emissions
Emissions <- Emissions %>%
  mutate(Xchange = Xf - X0) %>% 
  mutate (CO2 = Xchange*CO2EF) %>% 
  mutate (NOX = Xchange*NOXEF)

#Sum emissions by period (all, 11-3, 3pm-11am)
CO2All <- sum(Emissions$CO2)
NOXAll <- sum(Emissions$NOX)

CO2peak <- sum(Emissions$CO2[12:15])
NOXpeak <- sum(Emissions$NOX[12:15])
CO2other <- sum(Emissions$CO2[16:24], Emissions$CO2[1:11])
NOXother <- sum(Emissions$NOX[16:24], Emissions$NOX[1:11])

#Final Emissions Table
Emissions_Table <- data.frame("Time"= c("11am-3pm", "3pm-11am", "All"), "CO2lbs" = c(CO2peak,CO2other,CO2All), "NOXlbs" = c(NOXpeak, NOXother, NOXAll)) 


#curtailment cost: to be added


```


```{r Figures}

#need to stack both demand curves in one data frame for a legend

graph_table <- EV_Demand[c(1,5,14)] %>% 
  gather(condition,value,X0:Xt) %>% 
  mutate(Theoretical_Max=Max_Theory)


Demand_Graph <- ggplot(data = graph_table, aes(x = Hr)) +
  geom_line(aes(y = value, color=condition)) +
  theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
        panel.background = element_blank(), axis.line = element_line(colour = "black")) +
  labs(title="Hourly Demand Forecast", 
       subtitle="$0.05 Discount 11 AM - 3 PM \n 50% Throttling 6 AM - 11 AM",
       y="EV Charging Demand (kW)",
       x="Hour",
       color=NULL) +
  scale_x_continuous(breaks = 1:24, limits = c(1,24), expand = c(0, 0)) +
  scale_color_manual(labels=c("Baseline Demand","Demand with Intervention"), values = c("blue", "red")) +
  geom_rect(aes(xmin=6,xmax=11,ymin=-Inf,ymax=Inf,fill="Throttle"),alpha=0.0075) +
  geom_rect(aes(xmin=11,xmax=15,ymin=-Inf,ymax=Inf, fill = "Discount"),alpha=0.0075) +
  #theme_bw() + # theme_bw() gives grid lines, could remove
  theme(plot.title = element_text(hjust = 0.5)) + 
  theme(plot.subtitle = element_text(hjust = 0.5))+
 theme(legend.position="bottom") +
  scale_fill_manual('Interventions',values = c('green','yellow'),  guide = guide_legend(override.aes = list(alpha = 0.15)))

Potential_Graph <- Demand_Graph +
  geom_segment(aes(y=Theoretical_Max, yend=Theoretical_Max, x=11, xend=15))

# Aesthetic Notes:
# might try to remove space b/w Y-axis and hr0, as well as past hr24
# bold axis titles
# color brewer
# geom_line(aes(y=Theoretical_Max, x=11:15)) +

# If we want to graph the Max Theoretical Segment, we can use this:
# geom_segment(aes(y=Theoretical_Max, yend=Theoretical_Max, x=11, xend=15))


Demand_Graph
Potential_Graph

```

